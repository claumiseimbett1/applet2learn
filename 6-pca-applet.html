<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCA - Análisis de Componentes Principales</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
        }
        
        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            margin-right: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .chart-title {
            text-align: center;
            color: #555;
            margin-bottom: 10px;
            font-weight: 500;
        }
        
        canvas {
            display: block;
            margin: 0 auto;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
        }
        
        .stats {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .stat-box {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        .stat-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        
        .stat-value {
            color: #333;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .info-box h3 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .info-box p {
            color: #555;
            line-height: 1.6;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
                margin: 10px;
            }
            
            .visualization {
                grid-template-columns: 1fr;
            }
            
            .stats {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
            
            h1 {
                font-size: 2em;
            }
            
            canvas {
                max-width: 100%;
                height: auto;
            }
            
            .controls {
                padding: 15px;
            }
            
            button {
                padding: 10px 16px;
                font-size: 14px;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PCA - Análisis de Componentes Principales</h1>
        <p class="subtitle">Visualización interactiva de reducción de dimensionalidad</p>
        
        <div class="controls">
            <div class="control-group">
                <label>Número de puntos: <span id="pointsValue">50</span></label>
                <input type="range" id="pointsSlider" min="10" max="200" value="50">
            </div>
            
            <div class="control-group">
                <label>Dispersión de datos: <span id="spreadValue">30</span></label>
                <input type="range" id="spreadSlider" min="10" max="100" value="30">
            </div>
            
            <div class="control-group">
                <label>Correlación entre variables: <span id="correlationValue">0.5</span></label>
                <input type="range" id="correlationSlider" min="0" max="100" value="50">
            </div>
            
            <div class="control-group">
                <label>Componentes a mantener:</label>
                <select id="componentsSelect">
                    <option value="2">Mantener 2 componentes</option>
                    <option value="1">Reducir a 1 componente</option>
                </select>
            </div>
            
            <div class="control-group">
                <button onclick="generateData()">Generar Nuevos Datos</button>
                <button onclick="performPCA()">Ejecutar PCA</button>
                <button onclick="toggleAnimation()">Animar Transformación</button>
            </div>
        </div>
        
        <div class="visualization">
            <div class="chart-container">
                <h3 class="chart-title">Datos Originales (2D)</h3>
                <canvas id="originalCanvas" width="400" height="400"></canvas>
            </div>
            
            <div class="chart-container">
                <h3 class="chart-title">Después de PCA</h3>
                <canvas id="pcaCanvas" width="400" height="400"></canvas>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-box">
                <div class="stat-label">Varianza PC1</div>
                <div class="stat-value" id="pc1Variance">-</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Varianza PC2</div>
                <div class="stat-value" id="pc2Variance">-</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Varianza Total Explicada</div>
                <div class="stat-value" id="totalVariance">-</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Pérdida de Información</div>
                <div class="stat-value" id="infoLoss">-</div>
            </div>
        </div>
        
        <div class="info-box">
            <h3>¿Qué es PCA?</h3>
            <p>
                El Análisis de Componentes Principales (PCA) es una técnica de reducción de dimensionalidad que encuentra las direcciones de máxima varianza en los datos. 
                Los componentes principales son nuevos ejes ortogonales que capturan la mayor cantidad de información posible.
            </p>
            <p style="margin-top: 10px;">
                <strong>PC1 (Primer Componente):</strong> Dirección de máxima varianza<br>
                <strong>PC2 (Segundo Componente):</strong> Dirección ortogonal a PC1 con máxima varianza restante
            </p>
        </div>
    </div>
    
    <script>
        let data = [];
        let transformedData = [];
        let eigenvectors = [];
        let eigenvalues = [];
        let animationId = null;
        let animationProgress = 0;
        
        // Initialize
        window.onload = function() {
            setupEventListeners();
            generateData();
            performPCA();
        };
        
        function setupEventListeners() {
            document.getElementById('pointsSlider').addEventListener('input', function(e) {
                document.getElementById('pointsValue').textContent = e.target.value;
                generateData();
                performPCA();
            });
            
            document.getElementById('spreadSlider').addEventListener('input', function(e) {
                document.getElementById('spreadValue').textContent = e.target.value;
                generateData();
                performPCA();
            });
            
            document.getElementById('correlationSlider').addEventListener('input', function(e) {
                document.getElementById('correlationValue').textContent = (e.target.value / 100).toFixed(2);
                generateData();
                performPCA();
            });
            
            document.getElementById('componentsSelect').addEventListener('change', function(e) {
                performPCA(); // Recalcular PCA con nuevos componentes
            });
        }
        
        function generateData() {
            const numPoints = parseInt(document.getElementById('pointsSlider').value);
            const spread = parseInt(document.getElementById('spreadSlider').value);
            const correlation = parseInt(document.getElementById('correlationSlider').value) / 100;
            
            data = [];
            
            // Generar datos con correlación más realista usando distribución normal bivariada
            for (let i = 0; i < numPoints; i++) {
                // Generar dos números aleatorios independientes con distribución normal
                const u1 = Math.random();
                const u2 = Math.random();
                
                // Box-Muller transform para distribución normal
                const z1 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                const z2 = Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2);
                
                // Aplicar correlación
                const x = z1 * spread;
                let y = correlation * z1 + Math.sqrt(1 - correlation * correlation) * z2;
                y *= spread;
                
                // Añadir rotación para hacer los datos más interesantes visualmente
                const rotAngle = Math.PI / 6;
                const rotX = x * Math.cos(rotAngle) - y * Math.sin(rotAngle);
                const rotY = x * Math.sin(rotAngle) + y * Math.cos(rotAngle);
                
                data.push([rotX, rotY]);
            }
            
            drawOriginalData();
        }
        
        function drawOriginalData() {
            const canvas = document.getElementById('originalCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw axes
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            
            // Draw data points
            ctx.fillStyle = 'rgba(102, 126, 234, 0.6)';
            data.forEach(point => {
                const x = point[0] * 2 + canvas.width / 2;
                const y = -point[1] * 2 + canvas.height / 2;
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw eigenvectors if available
            if (eigenvectors.length > 0) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // PC1 - red
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                const pc1Scale = Math.sqrt(eigenvalues[0]) * 10;
                ctx.lineTo(
                    centerX + eigenvectors[0][0] * pc1Scale,
                    centerY - eigenvectors[0][1] * pc1Scale
                );
                ctx.stroke();
                
                // PC2 - green
                ctx.strokeStyle = '#44ff44';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                const pc2Scale = Math.sqrt(eigenvalues[1]) * 10;
                ctx.lineTo(
                    centerX + eigenvectors[1][0] * pc2Scale,
                    centerY - eigenvectors[1][1] * pc2Scale
                );
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = '#ff4444';
                ctx.font = 'bold 14px Arial';
                ctx.fillText('PC1', centerX + eigenvectors[0][0] * pc1Scale + 5, centerY - eigenvectors[0][1] * pc1Scale);
                
                ctx.fillStyle = '#44ff44';
                ctx.fillText('PC2', centerX + eigenvectors[1][0] * pc2Scale + 5, centerY - eigenvectors[1][1] * pc2Scale);
            }
        }
        
        function performPCA() {
            if (data.length === 0) return;
            
            try {
                if (data.length < 2) {
                    throw new Error('Se necesitan al menos 2 puntos de datos');
                }
            
            // Center the data
            const meanX = data.reduce((sum, p) => sum + p[0], 0) / data.length;
            const meanY = data.reduce((sum, p) => sum + p[1], 0) / data.length;
            
            const centeredData = data.map(p => [p[0] - meanX, p[1] - meanY]);
            
            // Calculate covariance matrix
            let covXX = 0, covXY = 0, covYY = 0;
            centeredData.forEach(p => {
                covXX += p[0] * p[0];
                covXY += p[0] * p[1];
                covYY += p[1] * p[1];
            });
            
            covXX /= data.length - 1;
            covXY /= data.length - 1;
            covYY /= data.length - 1;
            
            // Calculate eigenvalues and eigenvectors - more robust method
            const trace = covXX + covYY;
            const det = covXX * covYY - covXY * covXY;
            
            // Check for numerical stability
            const discriminant = trace * trace / 4 - det;
            if (discriminant < 0) {
                console.warn('Discriminant negativo, usando valores por defecto');
                eigenvalues = [Math.max(covXX, covYY), Math.min(covXX, covYY)];
                eigenvectors = [[1, 0], [0, 1]];
            } else {
                const sqrtDiscriminant = Math.sqrt(discriminant);
                const lambda1 = trace / 2 + sqrtDiscriminant;
                const lambda2 = trace / 2 - sqrtDiscriminant;
                
                eigenvalues = [Math.max(lambda1, lambda2), Math.min(lambda1, lambda2)];
                
                // Calculate eigenvectors - improved method
                if (Math.abs(covXY) > 1e-10) {
                    // For first eigenvector (largest eigenvalue)
                    let v1, v2;
                    
                    if (Math.abs(eigenvalues[0] - covXX) > 1e-10) {
                        v1 = [covXY, eigenvalues[0] - covXX];
                    } else {
                        v1 = [eigenvalues[0] - covYY, covXY];
                    }
                    
                    if (Math.abs(eigenvalues[1] - covXX) > 1e-10) {
                        v2 = [covXY, eigenvalues[1] - covXX];
                    } else {
                        v2 = [eigenvalues[1] - covYY, covXY];
                    }
                    
                    // Normalize eigenvectors
                    const norm1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);
                    const norm2 = Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
                    
                    if (norm1 > 1e-10 && norm2 > 1e-10) {
                        eigenvectors = [
                            [v1[0] / norm1, v1[1] / norm1],
                            [v2[0] / norm2, v2[1] / norm2]
                        ];
                    } else {
                        eigenvectors = [[1, 0], [0, 1]];
                    }
                } else {
                    // Diagonal case
                    if (covXX >= covYY) {
                        eigenvectors = [[1, 0], [0, 1]];
                    } else {
                        eigenvectors = [[0, 1], [1, 0]];
                    }
                }
            }
            
            // Transform data según componentes seleccionados
            const numComponents = parseInt(document.getElementById('componentsSelect').value);
            
            if (numComponents === 1) {
                // Reducir a 1D - solo primer componente
                transformedData = centeredData.map(p => [
                    p[0] * eigenvectors[0][0] + p[1] * eigenvectors[0][1],
                    0 // Segunda dimensión eliminada
                ]);
            } else {
                // Mantener 2D
                transformedData = centeredData.map(p => [
                    p[0] * eigenvectors[0][0] + p[1] * eigenvectors[0][1],
                    p[0] * eigenvectors[1][0] + p[1] * eigenvectors[1][1]
                ]);
            }
            
            // Update statistics - ahora con pérdida real
            const totalVar = eigenvalues[0] + eigenvalues[1];
            const retainedVar = numComponents === 1 ? eigenvalues[0] : totalVar;
            const varianceLoss = ((totalVar - retainedVar) / totalVar) * 100;
            
            document.getElementById('pc1Variance').textContent = ((eigenvalues[0] / totalVar) * 100).toFixed(1) + '%';
            document.getElementById('pc2Variance').textContent = ((eigenvalues[1] / totalVar) * 100).toFixed(1) + '%';
            document.getElementById('totalVariance').textContent = ((retainedVar / totalVar) * 100).toFixed(1) + '%';
            document.getElementById('infoLoss').textContent = varianceLoss.toFixed(1) + '%';
            
            drawOriginalData();
            drawTransformedData();
            } catch (error) {
                console.error('Error en PCA:', error);
                // Mostrar valores por defecto en caso de error
                document.getElementById('pc1Variance').textContent = '-';
                document.getElementById('pc2Variance').textContent = '-';
                document.getElementById('totalVariance').textContent = '-';
                document.getElementById('infoLoss').textContent = '-';
            }
        }
        
        function drawTransformedData() {
            const canvas = document.getElementById('pcaCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const numComponents = parseInt(document.getElementById('componentsSelect').value);
            
            // Draw axes
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            
            // Draw transformed axes labels
            ctx.fillStyle = '#ff4444';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('PC1', canvas.width - 30, canvas.height / 2 - 5);
            
            if (numComponents === 2) {
                ctx.fillStyle = '#44ff44';
                ctx.fillText('PC2', canvas.width / 2 + 5, 15);
            } else {
                ctx.fillStyle = '#cccccc';
                ctx.fillText('PC2 (eliminado)', canvas.width / 2 + 5, 15);
            }
            
            // Draw transformed data points
            ctx.fillStyle = 'rgba(118, 75, 162, 0.6)';
            transformedData.forEach(point => {
                const x = point[0] * 2 + canvas.width / 2;
                let y;
                
                if (numComponents === 1) {
                    // En reducción 1D, proyectar todos los puntos al eje horizontal
                    y = canvas.height / 2;
                } else {
                    y = -point[1] * 2 + canvas.height / 2;
                }
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Si es 1D, dibujar línea horizontal para mostrar la proyección
            if (numComponents === 1) {
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(50, canvas.height / 2);
                ctx.lineTo(canvas.width - 50, canvas.height / 2);
                ctx.stroke();
                
                // Etiqueta
                ctx.fillStyle = '#ff4444';
                ctx.font = '12px Arial';
                ctx.fillText('Datos proyectados en PC1', 10, canvas.height / 2 - 10);
            }
        }
        
        function toggleAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
                animationProgress = 0;
            } else {
                animateTransformation();
            }
        }
        
        function animateTransformation() {
            animationProgress += 0.02;
            
            if (animationProgress > 1) {
                animationProgress = 0;
            }
            
            const canvas = document.getElementById('pcaCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw axes
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            
            // Animate points
            ctx.fillStyle = 'rgba(118, 75, 162, 0.6)';
            
            const meanX = data.reduce((sum, p) => sum + p[0], 0) / data.length;
            const meanY = data.reduce((sum, p) => sum + p[1], 0) / data.length;
            
            data.forEach((point, i) => {
                const centeredPoint = [point[0] - meanX, point[1] - meanY];
                const transformedPoint = transformedData[i];
                
                // Interpolate between original and transformed
                const t = (Math.sin(animationProgress * Math.PI - Math.PI / 2) + 1) / 2; // Smooth easing
                const x = centeredPoint[0] * (1 - t) + transformedPoint[0] * t;
                const y = centeredPoint[1] * (1 - t) + transformedPoint[1] * t;
                
                const canvasX = x * 2 + canvas.width / 2;
                const canvasY = -y * 2 + canvas.height / 2;
                
                ctx.beginPath();
                ctx.arc(canvasX, canvasY, 4, 0, Math.PI * 2);
                ctx.fill();
            });
            
            animationId = requestAnimationFrame(animateTransformation);
        }
    </script>
</body>
</html>