<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XGBoost - Gradient Boosting Visualizado</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            color: #1e3c72;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 30px;
        }
        
        .controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            height: fit-content;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
            font-size: 0.9em;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
            color: #555;
        }
        
        button {
            width: 100%;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-bottom: 10px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(30, 60, 114, 0.4);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .visualization-area {
            display: grid;
            grid-template-rows: auto 1fr;
            gap: 20px;
        }
        
        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .chart-title {
            text-align: center;
            color: #333;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        canvas {
            display: block;
            margin: 0 auto;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
        }
        
        .trees-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            max-height: 300px;
            overflow-y: auto;
        }
        
        .tree-viz {
            display: inline-block;
            margin: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #ddd;
            text-align: center;
            min-width: 120px;
        }
        
        .tree-viz.active {
            border-color: #1e3c72;
            background: #e8f0ff;
        }
        
        .tree-number {
            font-weight: bold;
            color: #1e3c72;
            margin-bottom: 5px;
        }
        
        .tree-weight {
            font-size: 0.9em;
            color: #666;
        }
        
        .tree-prediction {
            font-size: 0.85em;
            color: #28a745;
            margin-top: 5px;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .metric-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        
        .metric-value {
            color: #1e3c72;
            font-size: 1.3em;
            font-weight: bold;
        }
        
        .info-box {
            background: #e8f0ff;
            border-left: 4px solid #1e3c72;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
        }
        
        .info-box h3 {
            color: #1e3c72;
            margin-bottom: 10px;
        }
        
        .info-box p {
            color: #555;
            line-height: 1.6;
            font-size: 0.9em;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            font-size: 0.9em;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 3px;
        }
        
        .status-bar {
            background: #28a745;
            color: white;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            margin-bottom: 15px;
            transition: background 0.3s;
        }
        
        .status-bar.training {
            background: #ffc107;
        }
        
        .status-bar.error {
            background: #dc3545;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .training-indicator {
            animation: pulse 1s infinite;
        }
        
        @media (max-width: 1200px) {
            .main-layout {
                grid-template-columns: 250px 1fr;
                gap: 20px;
            }
            
            .container {
                padding: 20px;
            }
        }
        
        @media (max-width: 768px) {
            .main-layout {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .charts-grid {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 15px;
                margin: 10px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .subtitle {
                font-size: 1em;
            }
            
            canvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>XGBoost - Extreme Gradient Boosting</h1>
        <p class="subtitle">Visualización interactiva del algoritmo de boosting con árboles de decisión</p>
        
        <div class="main-layout">
            <div class="controls">
                <div class="status-bar" id="status">
                    Estado: Listo
                </div>
                
                <div class="control-group">
                    <label>Número de árboles: <span id="numTreesValue">5</span></label>
                    <input type="range" id="numTrees" min="1" max="20" value="5">
                </div>
                
                <div class="control-group">
                    <label>Profundidad máxima: <span id="maxDepthValue">3</span></label>
                    <input type="range" id="maxDepth" min="1" max="6" value="3">
                </div>
                
                <div class="control-group">
                    <label>Tasa de aprendizaje: <span id="learningRateValue">0.3</span></label>
                    <input type="range" id="learningRate" min="0.01" max="1" step="0.01" value="0.3">
                </div>
                
                <div class="control-group">
                    <label>Regularización (λ): <span id="lambdaValue">1.0</span></label>
                    <input type="range" id="lambda" min="0" max="5" step="0.1" value="1.0">
                </div>
                
                <div class="control-group">
                    <label>Tipo de problema:</label>
                    <select id="problemType">
                        <option value="regression">Regresión</option>
                        <option value="classification">Clasificación binaria</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Conjunto de datos:</label>
                    <select id="dataset">
                        <option value="sine">Función seno con ruido</option>
                        <option value="linear">Lineal con outliers</option>
                        <option value="polynomial">Polinomial</option>
                        <option value="step">Función escalón</option>
                        <option value="circles">Círculos concéntricos</option>
                    </select>
                </div>
                
                <button id="generateBtn">Generar Datos</button>
                <button id="trainBtn">Entrenar XGBoost</button>
                <button id="stepBtn">Añadir Árbol</button>
                <button id="resetBtn">Reiniciar</button>
                
                <div class="info-box">
                    <h3>¿Cómo funciona?</h3>
                    <p>
                        XGBoost construye árboles de forma secuencial, donde cada árbol aprende de los errores del anterior.
                    </p>
                    <p style="margin-top: 10px;">
                        <strong>1.</strong> Comienza con una predicción inicial<br>
                        <strong>2.</strong> Calcula residuos (errores)<br>
                        <strong>3.</strong> Entrena un árbol con los residuos<br>
                        <strong>4.</strong> Actualiza predicciones<br>
                        <strong>5.</strong> Repite hasta convergencia
                    </p>
                </div>
            </div>
            
            <div class="visualization-area">
                <div class="trees-container" id="treesContainer">
                    <div class="chart-title">Árboles del Ensemble</div>
                    <div id="treesDisplay">
                        <p style="text-align: center; color: #999;">No hay árboles entrenados</p>
                    </div>
                </div>
                
                <div class="charts-grid">
                    <div class="chart-container">
                        <h3 class="chart-title">Datos y Predicciones</h3>
                        <canvas id="dataCanvas" width="400" height="400"></canvas>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #4CAF50;"></div>
                                <span>Datos reales</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #2196F3;"></div>
                                <span>Predicción XGBoost</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <h3 class="chart-title">Residuos por Iteración</h3>
                        <canvas id="residualsCanvas" width="400" height="400"></canvas>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #ff6b6b;"></div>
                                <span>Residuos actuales</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="metrics">
                    <div class="metric-box">
                        <div class="metric-label">Árboles Entrenados</div>
                        <div class="metric-value" id="treesCount">0</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Error (RMSE)</div>
                        <div class="metric-value" id="rmse">-</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">R² Score</div>
                        <div class="metric-value" id="r2">-</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Mejora (%)</div>
                        <div class="metric-value" id="improvement">-</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Variables globales
        let data = [];
        let predictions = [];
        let residuals = [];
        let trees = [];
        let currentTree = 0;
        let learningRate = 0.3;
        let maxDepth = 3;
        let lambda = 1.0;
        let initialError = 0;
        let isTraining = false;
        let problemType = 'regression';
        
        // Canvas setup
        const dataCanvas = document.getElementById('dataCanvas');
        const dataCtx = dataCanvas.getContext('2d');
        const residualsCanvas = document.getElementById('residualsCanvas');
        const residualsCtx = residualsCanvas.getContext('2d');
        
        // Event listeners
        document.getElementById('numTrees').addEventListener('input', function(e) {
            document.getElementById('numTreesValue').textContent = e.target.value;
        });
        
        document.getElementById('maxDepth').addEventListener('input', function(e) {
            maxDepth = parseInt(e.target.value);
            document.getElementById('maxDepthValue').textContent = e.target.value;
        });
        
        document.getElementById('learningRate').addEventListener('input', function(e) {
            learningRate = parseFloat(e.target.value);
            document.getElementById('learningRateValue').textContent = e.target.value;
        });
        
        document.getElementById('lambda').addEventListener('input', function(e) {
            lambda = parseFloat(e.target.value);
            document.getElementById('lambdaValue').textContent = e.target.value;
        });
        
        document.getElementById('dataset').addEventListener('change', generateData);
        document.getElementById('problemType').addEventListener('change', function(e) {
            problemType = e.target.value;
            generateData();
        });
        
        // Button event listeners
        document.getElementById('generateBtn').addEventListener('click', generateData);
        document.getElementById('trainBtn').addEventListener('click', trainModel);
        document.getElementById('stepBtn').addEventListener('click', trainStep);
        document.getElementById('resetBtn').addEventListener('click', reset);
        
        // Inicialización
        window.onload = function() {
            generateData();
        };
        
        function generateData() {
            try {
                const dataset = document.getElementById('dataset').value;
                problemType = document.getElementById('problemType').value;
                const numPoints = 100;
                
                data = [];
                
                if (!dataset) {
                    throw new Error('Tipo de dataset no seleccionado');
                }
            
            switch(dataset) {
                case 'sine':
                    for (let i = 0; i < numPoints; i++) {
                        const x = (i / numPoints) * 4 * Math.PI;
                        const y = Math.sin(x) + (Math.random() - 0.5) * 0.3;
                        data.push({ x: x, y: y, label: y > 0 ? 1 : 0 });
                    }
                    break;
                    
                case 'linear':
                    for (let i = 0; i < numPoints; i++) {
                        const x = (i / numPoints) * 10;
                        let y = 0.5 * x + 2 + (Math.random() - 0.5) * 2;
                        // Añadir algunos outliers
                        if (Math.random() < 0.1) {
                            y += (Math.random() - 0.5) * 10;
                        }
                        data.push({ x: x, y: y, label: y > 5 ? 1 : 0 });
                    }
                    break;
                    
                case 'polynomial':
                    for (let i = 0; i < numPoints; i++) {
                        const x = (i / numPoints) * 6 - 3;
                        const y = 0.5 * x * x - 2 * x + 1 + (Math.random() - 0.5) * 0.5;
                        data.push({ x: x, y: y, label: y > 2 ? 1 : 0 });
                    }
                    break;
                    
                case 'step':
                    for (let i = 0; i < numPoints; i++) {
                        const x = (i / numPoints) * 10;
                        let y = 0;
                        if (x < 2) y = 1;
                        else if (x < 4) y = 3;
                        else if (x < 6) y = 2;
                        else if (x < 8) y = 4;
                        else y = 1;
                        y += (Math.random() - 0.5) * 0.3;
                        data.push({ x: x, y: y, label: y > 2 ? 1 : 0 });
                    }
                    break;
                    
                case 'circles':
                    for (let i = 0; i < numPoints; i++) {
                        const angle = (i / numPoints) * 2 * Math.PI;
                        const radius = Math.random() < 0.5 ? 1 + Math.random() * 0.5 : 3 + Math.random() * 0.5;
                        const x = radius * Math.cos(angle) + 5;
                        const y = radius * Math.sin(angle) + 5;
                        data.push({ x: x, y: y, label: radius < 2 ? 0 : 1 });
                    }
                    break;
            }
            
            // Ordenar datos por x para mejor visualización
            data.sort((a, b) => a.x - b.x);
            
            // Validar que se generaron datos
            if (data.length === 0) {
                throw new Error('No se pudieron generar datos');
            }
            
            reset();
            drawData();
            updateStatus('Datos generados correctamente');
            } catch (error) {
                console.error('Error generando datos:', error);
                updateStatus('Error: ' + error.message, 'error');
                data = []; // Datos por defecto vacíos
            }
        }
        
        function reset() {
            // Predicciones iniciales más apropiadas
            predictions = data.map(d => {
                if (problemType === 'regression') {
                    return 0; // Comenzar en cero para regresión
                } else {
                    // Para clasificación, comenzar con log-odds de la media
                    const meanLabel = data.reduce((sum, point) => sum + point.label, 0) / data.length;
                    return Math.log(meanLabel / (1 - meanLabel + 1e-8)); // log-odds
                }
            });
            
            residuals = data.map((d, i) => {
                const target = problemType === 'regression' ? d.y : d.label;
                const pred = problemType === 'regression' ? predictions[i] : 
                           1 / (1 + Math.exp(-predictions[i])); // sigmoide para clasificación
                return target - pred;
            });
            trees = [];
            currentTree = 0;
            initialError = calculateRMSE();
            isTraining = false;
            
            updateMetrics();
            updateTreesDisplay();
            drawData();
            drawResiduals();
            updateStatus('Listo para entrenar');
        }
        
        function trainStep() {
            try {
                if (data.length === 0) {
                    throw new Error('No hay datos para entrenar. Genera datos primero.');
                }
                
                if (currentTree >= parseInt(document.getElementById('numTrees').value)) {
                    updateStatus('Entrenamiento completado', 'success');
                    return;
                }
                
                updateStatus('Entrenando árbol ' + (currentTree + 1), 'training');
            
            // Simular entrenamiento de un árbol
            const tree = buildTree(residuals);
            
            // Early stopping: si la ganancia es muy pequeña, detener entrenamiento
            if (tree.gain < 0.001) {
                updateStatus('Entrenamiento detenido - ganancia insuficiente', 'success');
                return;
            }
            
            trees.push(tree);
            
            // Actualizar predicciones
            for (let i = 0; i < data.length; i++) {
                const treePred = predictTree(tree, data[i].x);
                predictions[i] += learningRate * treePred;
                
                // Para clasificación, aplicar función sigmoide
                if (problemType === 'classification') {
                    // Función sigmoide más apropiada: 1 / (1 + e^(-x))
                    predictions[i] = 1 / (1 + Math.exp(-predictions[i]));
                    // Limitar valores extremos para estabilidad numérica
                    predictions[i] = Math.max(0.001, Math.min(0.999, predictions[i]));
                }
            }
            
            // Actualizar residuos
            for (let i = 0; i < data.length; i++) {
                const target = problemType === 'regression' ? data[i].y : data[i].label;
                residuals[i] = target - predictions[i];
            }
            
            currentTree++;
            
            updateMetrics();
            updateTreesDisplay();
            drawData();
            drawResiduals();
            
            if (currentTree >= parseInt(document.getElementById('numTrees').value)) {
                updateStatus('Entrenamiento completado', 'success');
            }
            } catch (error) {
                console.error('Error durante entrenamiento:', error);
                updateStatus('Error: ' + error.message, 'error');
            }
        }
        
        async function trainModel() {
            if (isTraining) return;
            
            isTraining = true;
            reset();
            
            const numTrees = parseInt(document.getElementById('numTrees').value);
            
            document.getElementById('trainBtn').disabled = true;
            document.getElementById('stepBtn').disabled = true;
            
            for (let i = 0; i < numTrees; i++) {
                trainStep();
                await sleep(500);
            }
            
            document.getElementById('trainBtn').disabled = false;
            document.getElementById('stepBtn').disabled = false;
            isTraining = false;
        }
        
        function buildTree(residuals) {
            // Implementación más realista del árbol de decisión para XGBoost
            const dataRange = Math.max(...data.map(d => d.x)) - Math.min(...data.map(d => d.x));
            const minX = Math.min(...data.map(d => d.x));
            
            // Encontrar el mejor split basado en los residuos
            let bestSplit = null;
            let bestGain = -Infinity;
            
            // Probar diferentes puntos de split
            const numCandidates = Math.min(20, data.length);
            for (let i = 0; i < numCandidates; i++) {
                const splitPoint = minX + (i / numCandidates) * dataRange;
                
                // Separar datos por el split
                const leftIndices = [];
                const rightIndices = [];
                
                data.forEach((point, idx) => {
                    if (point.x < splitPoint) {
                        leftIndices.push(idx);
                    } else {
                        rightIndices.push(idx);
                    }
                });
                
                if (leftIndices.length === 0 || rightIndices.length === 0) continue;
                
                // Calcular valores óptimos para cada hoja
                const leftSum = leftIndices.reduce((sum, idx) => sum + residuals[idx], 0);
                const rightSum = rightIndices.reduce((sum, idx) => sum + residuals[idx], 0);
                
                const leftValue = leftSum / (leftIndices.length + lambda);
                const rightValue = rightSum / (rightIndices.length + lambda);
                
                // Calcular ganancia (simplificada)
                const gain = (leftSum * leftSum) / (leftIndices.length + lambda) + 
                           (rightSum * rightSum) / (rightIndices.length + lambda);
                
                if (gain > bestGain) {
                    bestGain = gain;
                    bestSplit = {
                        point: splitPoint,
                        leftValue: leftValue,
                        rightValue: rightValue,
                        leftCount: leftIndices.length,
                        rightCount: rightIndices.length
                    };
                }
            }
            
            // Calcular peso óptimo del árbol basado en ganancia y regularización
            const optimalWeight = bestGain > 0 ? 
                Math.min(1.0, bestGain / (bestGain + lambda)) : 0.1;
            
            // Profundidad adaptativa basada en el número de datos y ganancia
            const adaptiveDepth = Math.min(maxDepth, 
                data.length < 50 ? 1 : 
                bestGain > 0.1 ? 2 : 1);
            
            return {
                split: bestSplit,
                weight: optimalWeight,
                depth: adaptiveDepth,
                gain: bestGain,
                treeId: currentTree + 1
            };
        }
        
        function predictTree(tree, x) {
            // Predicción basada en el split del árbol
            if (!tree.split) return 0;
            
            if (x < tree.split.point) {
                return tree.split.leftValue * tree.weight;
            } else {
                return tree.split.rightValue * tree.weight;
            }
        }
        
        // Cache para optimizar rendimiento
        let lastDataHash = '';
        let lastPredictionsHash = '';
        
        function drawData() {
            // Verificar si necesitamos redibujar
            const currentDataHash = JSON.stringify(data.slice(0, 10)) + data.length;
            const currentPredictionsHash = JSON.stringify(predictions.slice(0, 10)) + predictions.length;
            
            if (currentDataHash === lastDataHash && currentPredictionsHash === lastPredictionsHash) {
                return; // No redibujar si no hay cambios
            }
            
            lastDataHash = currentDataHash;
            lastPredictionsHash = currentPredictionsHash;
            
            dataCtx.clearRect(0, 0, dataCanvas.width, dataCanvas.height);
            
            // Dibujar ejes
            dataCtx.strokeStyle = '#e0e0e0';
            dataCtx.lineWidth = 1;
            dataCtx.beginPath();
            dataCtx.moveTo(40, dataCanvas.height - 40);
            dataCtx.lineTo(dataCanvas.width - 20, dataCanvas.height - 40);
            dataCtx.moveTo(40, 20);
            dataCtx.lineTo(40, dataCanvas.height - 40);
            dataCtx.stroke();
            
            // Escalar datos
            const xMin = Math.min(...data.map(d => d.x));
            const xMax = Math.max(...data.map(d => d.x));
            const yValues = problemType === 'regression' ? 
                data.map(d => d.y) : data.map(d => d.label);
            const yMin = Math.min(...yValues, ...predictions);
            const yMax = Math.max(...yValues, ...predictions);
            
            const xScale = (dataCanvas.width - 80) / (xMax - xMin || 1);
            const yScale = (dataCanvas.height - 80) / (yMax - yMin || 1);
            
            // Dibujar puntos de datos reales
            dataCtx.fillStyle = 'rgba(76, 175, 80, 0.6)';
            data.forEach(d => {
                const x = 40 + (d.x - xMin) * xScale;
                const yValue = problemType === 'regression' ? d.y : d.label;
                const y = dataCanvas.height - 40 - (yValue - yMin) * yScale;
                
                dataCtx.beginPath();
                dataCtx.arc(x, y, 4, 0, Math.PI * 2);
                dataCtx.fill();
            });
            
            // Dibujar predicciones
            if (predictions.length > 0 && trees.length > 0) {
                dataCtx.strokeStyle = '#2196F3';
                dataCtx.lineWidth = 2;
                dataCtx.beginPath();
                
                for (let i = 0; i < predictions.length; i++) {
                    const x = 40 + (data[i].x - xMin) * xScale;
                    const y = dataCanvas.height - 40 - (predictions[i] - yMin) * yScale;
                    
                    if (i === 0) {
                        dataCtx.moveTo(x, y);
                    } else {
                        dataCtx.lineTo(x, y);
                    }
                }
                
                dataCtx.stroke();
            }
            
            // Etiquetas de ejes
            dataCtx.fillStyle = '#666';
            dataCtx.font = '12px Arial';
            dataCtx.fillText('X', dataCanvas.width - 30, dataCanvas.height - 25);
            dataCtx.fillText('Y', 25, 30);
        }
        
        function drawResiduals() {
            residualsCtx.clearRect(0, 0, residualsCanvas.width, residualsCanvas.height);
            
            // Dibujar ejes
            residualsCtx.strokeStyle = '#e0e0e0';
            residualsCtx.lineWidth = 1;
            residualsCtx.beginPath();
            residualsCtx.moveTo(40, residualsCanvas.height / 2);
            residualsCtx.lineTo(residualsCanvas.width - 20, residualsCanvas.height / 2);
            residualsCtx.moveTo(40, 20);
            residualsCtx.lineTo(40, residualsCanvas.height - 40);
            residualsCtx.stroke();
            
            if (residuals.length === 0) return;
            
            // Escalar residuos
            const xMin = Math.min(...data.map(d => d.x));
            const xMax = Math.max(...data.map(d => d.x));
            const rMin = Math.min(...residuals);
            const rMax = Math.max(...residuals);
            const rAbsMax = Math.max(Math.abs(rMin), Math.abs(rMax)) || 1;
            
            const xScale = (residualsCanvas.width - 80) / (xMax - xMin || 1);
            const yScale = (residualsCanvas.height - 80) / (2 * rAbsMax);
            
            // Dibujar barras de residuos
            residuals.forEach((r, i) => {
                const x = 40 + (data[i].x - xMin) * xScale;
                const yZero = residualsCanvas.height / 2;
                const height = r * yScale;
                
                residualsCtx.fillStyle = r > 0 ? 'rgba(255, 107, 107, 0.6)' : 'rgba(107, 107, 255, 0.6)';
                residualsCtx.fillRect(x - 2, yZero, 4, -height);
            });
            
            // Línea cero
            residualsCtx.strokeStyle = '#333';
            residualsCtx.lineWidth = 1;
            residualsCtx.setLineDash([5, 5]);
            residualsCtx.beginPath();
            residualsCtx.moveTo(40, residualsCanvas.height / 2);
            residualsCtx.lineTo(residualsCanvas.width - 20, residualsCanvas.height / 2);
            residualsCtx.stroke();
            residualsCtx.setLineDash([]);
            
            // Etiquetas
            residualsCtx.fillStyle = '#666';
            residualsCtx.font = '12px Arial';
            residualsCtx.fillText('Residuos', residualsCanvas.width / 2 - 25, 15);
        }
        
        function updateTreesDisplay() {
            const container = document.getElementById('treesDisplay');
            
            if (trees.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #999;">No hay árboles entrenados</p>';
                return;
            }
            
            let html = '';
            trees.forEach((tree, i) => {
                const isActive = i === trees.length - 1;
                const gainColor = tree.gain > 0.1 ? '#28a745' : tree.gain > 0.01 ? '#ffc107' : '#dc3545';
                html += `
                    <div class="tree-viz ${isActive ? 'active' : ''}">
                        <div class="tree-number">Árbol ${i + 1}</div>
                        <div class="tree-weight">Peso: ${tree.weight.toFixed(3)}</div>
                        <div class="tree-weight">Profundidad: ${tree.depth}</div>
                        <div class="tree-prediction" style="color: ${gainColor}">
                            Ganancia: ${tree.gain.toFixed(4)}
                        </div>
                        <div class="tree-prediction">η = ${learningRate.toFixed(2)}</div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function calculateRMSE() {
            if (predictions.length === 0) return 0;
            
            let sum = 0;
            for (let i = 0; i < data.length; i++) {
                const target = problemType === 'regression' ? data[i].y : data[i].label;
                sum += Math.pow(target - predictions[i], 2);
            }
            
            return Math.sqrt(sum / data.length);
        }
        
        function calculateR2() {
            if (predictions.length === 0) return 0;
            
            const targets = data.map(d => problemType === 'regression' ? d.y : d.label);
            const mean = targets.reduce((sum, t) => sum + t, 0) / targets.length;
            
            let ssRes = 0;
            let ssTot = 0;
            
            for (let i = 0; i < data.length; i++) {
                const target = problemType === 'regression' ? data[i].y : data[i].label;
                ssRes += Math.pow(target - predictions[i], 2);
                ssTot += Math.pow(target - mean, 2);
            }
            
            return ssTot === 0 ? 0 : 1 - (ssRes / ssTot);
        }
        
        function updateMetrics() {
            document.getElementById('treesCount').textContent = trees.length;
            
            const rmse = calculateRMSE();
            document.getElementById('rmse').textContent = rmse.toFixed(4);
            
            const r2 = calculateR2();
            document.getElementById('r2').textContent = r2.toFixed(4);
            
            if (initialError > 0 && trees.length > 0) {
                const improvement = ((initialError - rmse) / initialError * 100);
                document.getElementById('improvement').textContent = improvement.toFixed(1) + '%';
            } else {
                document.getElementById('improvement').textContent = '-';
            }
        }
        
        function updateStatus(message, type = 'normal') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = 'Estado: ' + message;
            
            statusEl.className = 'status-bar';
            if (type === 'training') {
                statusEl.className = 'status-bar training training-indicator';
            } else if (type === 'error') {
                statusEl.className = 'status-bar error';
            }
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>
        